# syscall_logger/syscall_table.py

# Dicionário de mapeamento de números de syscall para nomes (para arquitetura x86-64)
# Esta é uma lista parcial. Uma ferramenta completa precisaria de um mapeamento exaustivo.
SYSCALL_NAMES = {
    0: "read",
    1: "write",
    2: "open",
    3: "close",
    4: "stat",
    5: "fstat",
    6: "lstat",
    7: "poll",
    8: "lseek",
    9: "mmap",
    10: "mprotect",
    11: "munmap",
    12: "brk",
    13: "rt_sigaction",
    14: "rt_sigprocmask",
    15: "rt_sigreturn",
    16: "ioctl",
    17: "pread64",
    18: "pwrite64",
    19: "readv",
    20: "writev",
    21: "access",
    22: "pipe",
    23: "select",
    24: "sched_yield",
    25: "mremap",
    26: "msync",
    27: "mincore",
    28: "madvise",
    228: "set_robust_list",
    229: "get_robust_list",
    230: "splice",
    231: "tee",
    232: "sync_file_range",
    233: "vmsplice",
    234: "move_pages",
    235: "utimensat",
    236: "epoll_pwait",
    237: "signalfd",
    238: "timerfd_create",
    239: "eventfd",
    240: "fallocate",
    241: "timerfd_settime",
    242: "timerfd_gettime",
    243: "accept4",
    244: "signalfd4",
    245: "eventfd2",
    246: "epoll_create1",
    247: "dup3",
    248: "pipe2",
    249: "inotify_init1",
    250: "preadv",
    251: "pwritev",
    252: "rt_tgsigqueueinfo",
    253: "perf_event_open",
    254: "recvmmsg",
    255: "fanotify_init",
    256: "fanotify_mark",
    257: "prlimit64",
    258: "name_to_handle_at",
    259: "open_by_handle_at",
    260: "clock_adjtime",
    261: "syncfs",
    262: "sendmmsg",
    263: "setns",
    264: "getcpu",
    265: "process_vm_readv",
    266: "process_vm_writev",
    267: "kcmp",
    268: "finit_module",
    269: "sched_setattr",
    270: "sched_getattr",
    271: "renameat2",
    272: "seccomp",
    273: "getrandom",
    274: "memfd_create",
    275: "kexec_file_load",
    276: "bpf",
    277: "execveat",
    278: "userfaultfd",
    279: "membarrier",
    280: "mlock2",
    281: "copy_file_range",
    282: "preadv2",
    283: "pwritev2",
    284: "pkey_mprotect",
    285: "pkey_alloc",
    286: "pkey_free",
    287: "statx",
    288: "io_pgetevents",
    289: "rseq",
    439: "pidfd_send_signal",
    440: "io_uring_setup",
    441: "io_uring_enter",
    442: "io_uring_register",
    443: "open_tree",
    444: "move_mount",
    445: "fsopen",
    446: "fsconfig",
    447: "fsmount",
    448: "fspick",
    449: "pidfd_open",
    450: "clone3",
    451: "close_range",
    452: "faccessat2",
    453: "fchmodat2",
    454: "epoll_pwait2",
    455: "mount_setattr",
    456: "quotactl_fd",
    457: "landlock_create_ruleset",
    458: "landlock_add_rule",
    459: "landlock_restrict_self",
    460: "memfd_secret",
    461: "process_madvise",
    462: "futex_waitv",
    463: "set_mempolicy_home_node",
    464: "cachestat",
    465: "fchmodat_common",
    466: "faccessat_common",
    # ... adicione mais syscalls conforme necessário
}

def get_syscall_name(syscall_num):
    """Retorna o nome da syscall dado o seu número."""
    return SYSCALL_NAMES.get(syscall_num, f"UNKNOWN_{syscall_num}")